{"version":3,"file":"../checkout-validation-131.min.js","sources":["checkout-validation-131.js"],"sourcesContent":["/**\n * Manage checkout front-end validation.\n *\n * DEPENDS ON:\n * - jQuery // Interact with WooCommerce events\n */\n\n(function (root, factory) {\n\tif ( typeof define === 'function' && define.amd ) {\n\t\tdefine([], factory(root));\n\t} else if ( typeof exports === 'object' ) {\n\t\tmodule.exports = factory(root);\n\t} else {\n\t\troot.CheckoutValidation = factory(root);\n\t}\n})(typeof global !== 'undefined' ? global : this.window || this.global, function (root) {\n\n\t'use strict';\n\n\tvar $ = jQuery;\n\n\tvar _hasInitialized = false;\n\tvar _hasJQuery = ( $ != null );\n\tvar _publicMethods = { };\n\tvar _settings = {\n\t\tbodyClass: 'fc-checkout-validation--active',\n\t\tformSelector: 'form.checkout',\n\t\tformRowSelector: '.form-row',\n\t\tvalidateFieldsSelector: '.input-text, select',\n\t\tclearValidationCountryChangedSelector: '#state, #shipping_state, #billing_state',\n\t\talwaysValidateFieldsSelector: '',\n\t\tselect2Selector: '.select2, .select2-hidden-accessible',\n\t\ttypeRequiredSelector: '.validate-required',\n\t\ttypeEmailSelector: '.validate-email',\n\t\ttypeConfirmationSelector: '[data-confirm-with]',\n\t\tvalidClass: 'woocommerce-validated',\n\t\tinvalidClass: 'woocommerce-invalid',\n\t\tvalidationMessages: {\n\t\t\trequired:         'This is a required field.',\n\t\t\temail:            'This is not a valid email address.',\n\t\t\tconfirmation:     'This field does not match the related',\n\t\t},\n\t};\n\n\tvar _validationTypes = {\n\t\trequired:         'required-field',\n\t\temail:            'email',\n\t\tconfirmation:     'confirmation-field',\n\t};\n\n\n\n\t/**\n\t * METHODS\n\t */\n\n\n\n\t/*!\n\t* Merge two or more objects together.\n\t* (c) 2017 Chris Ferdinandi, MIT License, https://gomakethings.com\n\t* @param   {Boolean}  deep     If true, do a deep (or recursive) merge [optional]\n\t* @param   {Object}   objects  The objects to merge together\n\t* @returns {Object}            Merged values of defaults and options\n\t*/\n\tvar extend = function () {\n\t\t// Variables\n\t\tvar extended = {};\n\t\tvar deep = false;\n\t\tvar i = 0;\n\n\t\t// Check if a deep merge\n\t\tif ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {\n\t\t\tdeep = arguments[0];\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge the object into the extended object\n\t\tvar merge = function (obj) {\n\t\t\tfor (var prop in obj) {\n\t\t\t\tif (obj.hasOwnProperty(prop)) {\n\t\t\t\t\t// If property is an object, merge properties\n\t\t\t\t\tif (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {\n\t\t\t\t\t\textended[prop] = extend(extended[prop], obj[prop]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\textended[prop] = obj[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Loop through each object and conduct a merge\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar obj = arguments[i];\n\t\t\tmerge(obj);\n\t\t}\n\n\t\treturn extended;\n    };\n\t\n\n\n\t/**\n\t * Check if field is hidden to the user.\n\t * @param  {Field}  field Field to test visibility.\n\t * @return {Boolean}      True if field is hidden to the user.\n\t */\n\tvar isFieldHidden = function( field ) {\n\t\treturn ( field.offsetParent === null );\n\t};\n\n\n\n\t/**\n\t * Check if field is in allow list for always validate.\n\t * @param  {Field}  field  Field to test for allow list.\n\t * @return {Boolean}       True if field is in allow list for always validate.\n\t */\n\tvar isAlwaysValidate = function( field ) {\n\t\t// Bail if field not found or selector empty\n\t\tif ( ! field || ! _settings.alwaysValidateFieldsSelector ) { return false; }\n\n\t\t// Check if field is in allow list\n\t\tif ( field.matches( _settings.alwaysValidateFieldsSelector ) ) { return true; }\n\t\treturn false;\n\t};\n\n\t\n\n\t/**\n\t * Get the form-row element related to the field.\n\t * @param  {Field} field Form field.\n\t * @return {Element}     Form row related to the passed field.\n\t */\n\tvar getFormRow = function( field ) {\n\t\t// Bail if field not valid\n\t\tif ( !field ) { return; }\n\n\t\treturn field.closest( _settings.formRowSelector );\n\t};\n\n\n\n\t/**\n\t * Add markup for inline message of required fields.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row related to the field.\n\t * @param  {String} message   Message to add.\n\t * @param  {String} typeClass Type of error used to identify which message to display on validation.\n\t */\n\tvar addInlineMessageMarkup = function( field, formRow, message, typeClass ) {\n\t\t// Bail if field not valid\n\t\tif ( !field ) { return; }\n\n\t\tvar referenceNode = field;\n\n\t\t// Change reference field for select2\n\t\tif ( isSelect2Field( field ) ) {\n\t\t\tvar newReference = field.parentNode.querySelector( '.select2-container' );\n\t\t\tif ( newReference ) { referenceNode = newReference; }\n\t\t}\n\n\t\t// Create message element and add it after the field.\n\t\tvar parent = field.parentNode;\n\t\tvar element = document.createElement( 'span' );\n\t\telement.className = 'woocommerce-error invalid-' + typeClass;\n\t\telement.innerText = message;\n\t\tparent.insertBefore( element, referenceNode.nextSibling );\n\t};\n\n\n\n\t/**\n\t * Add markup for inline message of required fields.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row related to the field.\n\t */\n\tvar initInlineMessageRequired = function( field, formRow ) {\n\t\tvar message = _settings.validationMessages.required;\n\t\taddInlineMessageMarkup( field, formRow, message, 'required-field' );\n\t};\n\n\n\n\t/**\n\t * Add markup for inline message of email fields.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row related to the field.\n\t */\n\tvar initInlineMessageEmail = function( field, formRow ) {\n\t\tvar message = _settings.validationMessages.email;\n\t\taddInlineMessageMarkup( field, formRow, message, 'email' );\n\t};\n\n\n\n\t/**\n\t * Add markup for inline message of confirmation fields.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row related to the field.\n\t */\n\tvar initInlineMessageConfirmation = function( field, formRow ) {\n\t\tvar message = _settings.validationMessages.confirmation;\n\n\t\t// Try get message from field attributes\n\t\tif ( field.getAttribute( 'data-invalid-confirm-with' ) ) {\n\t\t\tmessage = field.getAttribute( 'data-invalid-confirm-with' );\n\t\t}\n\n\t\taddInlineMessageMarkup( field, formRow, message, 'confirmation-field' );\n\t};\n\n\n\n\t/**\n\t * Initalize inline validation messages.\n\t */\n\tvar initInlineMessages = function() {\n\t\tvar form = document.querySelector( _settings.formSelector );\n\n\t\t// Bail if form not found\n\t\tif ( !form ) { return; }\n\n\t\tvar fields = form.querySelectorAll( _settings.validateFieldsSelector );\n\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar field = fields[i],\n\t\t\t\t\tformRow = getFormRow( field );\n\n\t\t\t// Continue to next field if form row not found\n\t\t\tif ( !formRow ) { continue; }\n\n\t\t\t// Proceed if field needs validation\n\t\t\tif ( needsValidationMessage( field, formRow ) ) {\n\t\t\t\tif ( isRequiredField( formRow ) ) { initInlineMessageRequired( fields[i], formRow ); }\n\t\t\t\tif ( isEmailField( formRow ) ) { initInlineMessageEmail( fields[i], formRow ); }\n\t\t\t\tif ( isConfirmationField( formRow ) ) { initInlineMessageConfirmation( fields[i], formRow ); }\n\t\t\t}\n\t\t}\n\t};\n\n\t\n\n\t/**\n\t * Check field is a select2 element.\n\t * @param  {Field}  field     Field to check.\n\t * @return {Boolean}          True if field is select2.\n\t */\n\tvar isSelect2Field = function( field ) {\n\t\tif ( field.closest( _settings.select2Selector ) ) { return true; }\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Check if field is a select field.\n\t * @param  {Element}  field  Field to check.\n\t * @return {Boolean}         True if is a select field.\n\t */\n\tvar isSelectField = function( field ) {\n\t\tif ( field.matches( 'select' ) ) { return true; }\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Check if field has value.\n\t * @param  {Field}   field  Field to check.\n\t * @return {Boolean}        True if field has value.\n\t */\n\tvar hasValue = function( field ) {\n\t\t// Check for select 2 field\n\t\tif ( isSelectField( field ) ) {\n\t\t\tif ( field.options && field.selectedIndex > -1 && field.options[ field.selectedIndex ].value != '' ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check for all other fields\n\t\tif ( field.value != '' ) { return true; }\n\t\t\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Check if form row is required.\n\t * @param  {Element}  formRow Form row element.\n\t * @return {Boolean}          True if required.\n\t */\n\tvar isRequiredField = function( formRow ) {\n\t\tif ( formRow.matches( _settings.typeRequiredSelector ) ) { return true; }\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Validate required field.\n\t * @param  {Field} field Field for validation.\n\t */\n\tvar validateRequired = function( field, formRow ) {\n\t\t// Bail if has value\n\t\tif ( hasValue( field ) ) { return [ 'required', true ]; }\n\n\t\t// Return classes for invalid field\n\t\treturn [ 'required', _validationTypes.required ];\n\t};\n\n\n\n\t/**\n\t * Check if form row is email field.\n\t * @param  {Element}  formRow Form row element.\n\t * @return {Boolean}          True if is email field.\n\t */\n\tvar isEmailField = function( formRow ) {\n\t\tif ( formRow.matches( _settings.typeEmailSelector ) ) { return true; }\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Validate email field.\n\t * @param  {Field} field Field for validation.\n\t */\n\tvar validateEmail = function( field, formRow ) {\n\t\t// Bail if does not have value\n\t\tif ( ! hasValue( field ) ) { return [ 'email', true ]; }\n\n\t\t/* https://stackoverflow.com/questions/2855865/jquery-validate-e-mail-address-regex */\n\t\tvar emailPattern = new RegExp(/^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i);\n\n\t\t// Validate email value\n\t\tif ( emailPattern.test( field.value ) ) { return [ 'email', true ]; }\n\n\t\t// Return classes for invalid field\n\t\treturn [ 'email', _validationTypes.email ];\n\t};\n\n\n\n\t/**\n\t * Check if form row is a confirmation field.\n\t * @param  {Element}  formRow Form row element.\n\t * @return {Boolean}          True if is a confimation field.\n\t */\n\tvar isConfirmationField = function( formRow ) {\n\t\tif ( formRow.querySelector( _settings.typeConfirmationSelector ) ) { return true; }\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Validate confirmation field.\n\t * @param  {Field} field Field for validation.\n\t */\n\tvar validateConfirmation = function( field, formRow ) {\n\t\t// Bail if does not have value\n\t\tif ( ! hasValue( field ) ) { return [ 'confirmation', true ]; }\n\n\t\t// Get confirmation field\n\t\tvar form = formRow.closest( 'form' );\n\t\tvar confirmWith = form ? form.querySelector( field.getAttribute( 'data-confirm-with' ) ) : null;\n\n\t\t// Validate fields have same value\n\t\tif ( confirmWith && field.value == confirmWith.value ) { return [ 'confirmation', true ]; }\n\n\t\t// Return classes for invalid field\n\t\treturn [ 'confirmation', _validationTypes.confirmation ];\n\t};\n\n\n\n\t/**\n\t * Check if field needs validation.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row for validation.\n\t * @return {Boolean}          True if field needs any validation.\n\t */\n\tvar needsValidation = function( field, formRow ) {\n\t\t// Bail if field should always validate\n\t\tif ( isAlwaysValidate( field ) ) { return true; }\n\n\t\t// Test validation types\n\t\tif ( isRequiredField( formRow ) ) { return true; }\n\t\tif ( isEmailField( formRow ) ) { return true; }\n\t\tif ( isConfirmationField( formRow ) ) { return true; }\n\n\t\treturn false;\n\t};\n\n\n\n\t/**\n\t * Check if field needs validation message markup.\n\t * @param  {Field} field      Field to validate.\n\t * @param  {Element} formRow  Form row for validation.\n\t * @return {Boolean}          True if field needs any validation.\n\t */\n\tvar needsValidationMessage = function( field, formRow ) {\n\t\t// Check existence of message markup\n\t\tif ( formRow.querySelector( '.woocommerce-error' ) ) { return false; }\n\n\t\t// Check if field needs validation\n\t\tif ( ! needsValidation( field, formRow ) ) { return false; }\n\t\t\n\t\treturn true;\n\t};\n\n\n\n\t/**\n\t * Process validation results of a field.\n\t * @param  {Field} field             Field to validation.\n\t * @param  {Element} formRow          Form row element.\n\t * @param  {Array} validationResults Validation results array.\n\t * @return {Boolean}           True if all fields are valid.\n\t */\n\tvar processValidationResults = function( field, formRow, validationResults ) {\n\t\tvar valid = true;\n\n\t\t// Iterate validation results\n\t\tfor ( var i = 0; i < validationResults.length; i++ ) {\n\t\t\tvar type    = validationResults[i][0],\n\t\t\t\t\tresult  = validationResults[i][1];\n\n\t\t\t// Remove invalidation classes from the field\n\t\t\tif ( true === result ) {\n\t\t\t\t// TODO: Maybe refactor to use classList.toggle\n\t\t\t\t// Remove invalid classes for validation type\n\t\t\t\tformRow.classList.remove( _settings.invalidClass +'-'+ _validationTypes[ type ] );\n\t\t\t}\n\t\t\t// Add invalidation classes to the field\n\t\t\telse {\n\t\t\t\tvalid = false;\n\t\t\t\t// TODO: Maybe refactor to use classList.toggle\n\t\t\t\tformRow.classList.add( _settings.invalidClass +'-'+ result );\n\t\t\t}\n\t\t}\n\n\t\t// Toggle valid/invalid classes\n\t\tformRow.classList.toggle( _settings.validClass, valid );\n\t\tformRow.classList.toggle( _settings.invalidClass, ! valid );\n\n\t\treturn valid;\n\t};\n\n\n\n\t/**\n\t * Clear the state fields validation status classes when the field loses the value due changes to the country fields.\n\t *\n\t * @param   jQuery.Event  event    Event object as a `jQuery.Event`.\n\t * @param   string        country  Selected country code value of the related country field.\n\t * @param   jQuery.fn     wrapper  jQuery object representing the field wrapper element related to the country field that was changed. See variable `wrapper_selectors` ~LN103 of the `country-select.js`.\n\t */\n\tvar maybeClearStateFields = function( event, country, wrapper ) {\n\t\t// Bail if jQuery is not available\n\t\tif ( ! _hasJQuery ) { return; }\n\t\t\n\t\tvar wrappersList = $( wrapper ).toArray();\n\n\t\twrappersList.forEach( function( wrapperItem ) {\n\t\t\t\n\t\t\tvar fields = Array.from( wrapperItem.querySelectorAll( _settings.clearValidationCountryChangedSelector ) );\n\t\t\t\n\t\t\tfields.forEach( function( field ) {\n\t\t\t\t\n\t\t\t\tif ( '' == field.value ) {\n\t\t\t\t\tvar formRow = field.closest( _settings.formRowSelector );\n\t\t\t\t\t_publicMethods.clearValidationResults( field, formRow );\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\t};\n\n\n\n\t/**\n\t * Clear validation results status of a field.\n\t * @param  {Field} field             Field to validation.\n\t * @param  {Element} formRow          Form row element.\n\t */\n\t_publicMethods.clearValidationResults = function( field, formRow ) {\n\t\t// Bail if field or form row invalid\n\t\tif ( ! field || ! formRow ) { return; }\n\t\t\n\t\t// Remove invalid classes for validation types\n\t\tvar validationTypeKeys = Object.keys( _validationTypes );\n\t\tfor ( var i = 0; i < validationTypeKeys.length; i++ ) {\n\t\t\tvar type = validationTypeKeys[i];\n\t\t\tformRow.classList.remove( _settings.invalidClass +'-'+ _validationTypes[ type ] );\n\t\t}\n\n\t\t// Remove valid/invalid classes\n\t\tformRow.classList.remove( _settings.validClass );\n\t\tformRow.classList.remove( _settings.invalidClass );\n\t};\n\n\n\n\t/**\n\t * Handle document clicks and route to the appropriate function.\n\t */\n\tvar handleValidateEvent = function( e ) {\n\t\tvar field = e.target;\n\n\t\t// Get correct field when is select2\n\t\tif ( isSelect2Field( e.target ) ) {\n\t\t\tfield = e.target.closest( _settings.formRowSelector ).querySelector( 'select' );\n\t\t}\n\n\t\t_publicMethods.validateField( field );\n\t};\n\n\n\n\t/**\n\t * Test multiple validations on the passed field.\n\t * @param  {Field} field    Field for validation.\n\t * @return {Boolean}        True if field is valid.\n\t */\n\t_publicMethods.validateField = function( field, validateHidden ) {\n\t\t// Bail if field is null\n\t\tif ( ! field ) { return true; }\n\n\t\tvar validationResults = [],\n\t\t\tformRow = getFormRow( field );\n\n\t\t// Bail if formRow not found\n\t\tif ( ! formRow ) { return true; }\n\n\t\t// Bail if hidden to the user\n\t\tif ( ! isAlwaysValidate( field ) && validateHidden !== true && isFieldHidden( field ) ) { return true; }\n\n\t\t// Bail if field doesn't need validation\n\t\tif ( ! needsValidation( field, formRow ) ) { return true; }\n\n\t\t// Perform validations\n\t\tif ( isRequiredField( formRow ) ) { validationResults.push( validateRequired( field, formRow ) ); }\n\t\tif ( isEmailField( formRow ) ) { validationResults.push( validateEmail( field, formRow ) ); }\n\t\tif ( isConfirmationField( formRow ) ) { validationResults.push( validateConfirmation( field, formRow ) ); }\n\n\t\t// TODO: Trigger validation of related fields (ie zip > State, Country)\n\n\t\t// Process results\n\t\treturn processValidationResults( field, formRow, validationResults );\n\t};\n\n\n\n\t/**\n\t * Trigger validation in all fields inside the container.\n\t * @param  {Element} container Element to look for fields in, if not passed consider the checkout form as container.\n\t * @return {Boolean}           True if all fields are valid.\n\t */\n\t_publicMethods.validateAllFields = function( container, validateHidden ) {\n\t\tif ( ! container ) { container = document.querySelector( _settings.formSelector ) }\n\n\t\tvar all_valid = true;\n\t\tvar fields = container.querySelectorAll( _settings.validateFieldsSelector );\n\n\t\tfor ( var i = 0; i < fields.length; i++ ) {\n\t\t\tif ( ! _publicMethods.validateField( fields[i], validateHidden ) ) {\n\t\t\t\tall_valid = false;\n\t\t\t}\n\t\t}\n\n\t\treturn all_valid;\n\t};\n\n\t\n\n\t/**\n\t * Initialize component and set related handlers.\n\t */\n\t_publicMethods.init = function( options ) {\n\t\tif ( _hasInitialized ) return;\n\n\t\t// Merge settings\n\t\t_settings = extend( _settings, options );\n\n\t\t// Initialize message to listen for changes\n\t\tinitInlineMessages();\n\t\t\n\t\t// Add body class\n\t\tdocument.body.classList.add( _settings.bodyClass );\n\n\t\tif ( _hasJQuery ) {\n\t\t\t$( _settings.formSelector ).on( 'input validate change', _settings.validateFieldsSelector, handleValidateEvent );\n\t\t\t\n\t\t\t// Run on checkout or cart changes\n\t\t\t$( document ).on( 'load_ajax_content_done', _publicMethods.init );\n\t\t\t$( document ).on( 'updated_checkout', initInlineMessages );\n\t\t\t$( document ).on( 'country_to_state_changed', maybeClearStateFields );\n\t\t}\n\n\t\t_hasInitialized = true;\n\t};\n\n\n\t\n\t//\n\t// Public APIs\n\t//\n\treturn _publicMethods;\n\n});\n"],"names":["root","factory","define","amd","exports","module","CheckoutValidation","global","this","window","isAlwaysValidate","field","_settings","alwaysValidateFieldsSelector","matches","getFormRow","closest","formRowSelector","addInlineMessageMarkup","formRow","message","typeClass","referenceNode","parent","isSelect2Field","newReference","parentNode","querySelector","element","document","createElement","className","innerText","insertBefore","nextSibling","initInlineMessages","form","formSelector","fields","querySelectorAll","validateFieldsSelector","i","length","needsValidationMessage","isRequiredField","validationMessages","required","isEmailField","email","isConfirmationField","confirmation","getAttribute","hasValue","options","selectedIndex","value","needsValidation","maybeClearStateFields","event","country","wrapper","_hasJQuery","$","toArray","forEach","wrapperItem","Array","from","clearValidationCountryChangedSelector","_publicMethods","clearValidationResults","jQuery","_hasInitialized","bodyClass","select2Selector","typeRequiredSelector","typeEmailSelector","typeConfirmationSelector","validClass","invalidClass","_validationTypes","extend","extended","deep","Object","prototype","toString","call","arguments","obj","prop","hasOwnProperty","merge","validationTypeKeys","keys","type","classList","remove","handleValidateEvent","e","target","validateField","validateHidden","validationResults","offsetParent","push","RegExp","test","confirmWith","validateConfirmation","valid","result","add","toggle","processValidationResults","validateAllFields","container","all_valid","init","body","on"],"mappings":"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"}